# 정리
---
- 서블릿 : 자바 기반으로 데이터를 동적으로 처리하기 위한 프로그램. 기존 CGI는 요청이 들어올때마다 CGI프로그램이 프로세스단위로 실행되어 웹사용자가 많아지면 서버에 부하가 걸렸다. **그래서 Servlet은 프로세스1개의 내부에 '스레드 풀'이라는 스레드들이 생성될 수 있는 공간을 만들어 멀티스레드로 처리한다!** 서블릿의 실행환경은 Tomcat이다. 
- 웹어플리케이션 : 일반적인 웹서버는 정적인 처리만 가능하지만, 톰캣은 **웹 어플리케이션 서버로 DB연결, 다른 응용프로그램과 상호작용 등 동적인 기능을 사용할 수 있다.** 톰캣은 Apache 웹서버의 일부기능+web container조합으로 웹서버의 정적 데이터 처리기능과 동적 데이터 처리기능 모두를 포함하고 있다. 하나의 톰캣은 하나의 JVM을 가지고 있다. 서블릿은 Web Application Server안에서 구동된다. 처음 클라이언트의 요청을 받은 웹서버는 WAS Server의 웹서버에 전달하고 WAS Server의 웹서버는 해당 요청이 동적 페이지 요청일 시 HTTP요청을 Servlet Container에 전달한다. 서블릿 컨테이너는 요청을 처리해 WAS의 웹서버>HTTP응답을 웹서버에 전달> 받은 HTTP응답을 클라이언트에 전달한다.
- 서블릿 컨테이너 : 서블릿을 관리해주는 고마운 자식. 서블릿이 요구사항명세서라면 서브릿컨테이너는 명세서를 보고 개발하는 개발자. **클라이언트의 Request를 받아주고 Response할 수 있게 웹서버와 소켓을 만들어 통신한다.**
- ?서블릿 컨테이너는 어떻게 요청을 처리할까? 웹서버가 HTTP요청을 받는다>> 웹서버는 요청을 서블릿컨테이너로 전달한다>> 서블릿이 컨테이너에 없다면 서블릿을 동적으로 검색하여 컨테이너의 주소공간에 로드한다>> 컨테이너가 서블릿의 init()메소드를 호출하면, 서블릿이 초기화된다(서블릿이 처음 로드됐을 떄 한 번만 호출)>>컨테이너가 서블릿의 servise()메소드를 호출하여 HTTP요청을 처리한다>>웹 서버는 동적으로 생성된 결과를 반환한다.
서블릿을 사용하는 것은 JVM이 각 요청을 분리된 자바 스레드 내부에서 처리하도록 하는 것인데 이는 서블릿 컨테이너의 주요 장점 중 하나이다!
- ?하나의 톰캣에 여러 웹어플리케이션을 띄울 수 있지 않을까?
하나의 톰캣서버는 여러개의 웹어플리케이션을 배포하여 운영할 수 있따. 각각의 웹 어플리케이션은 별도의 서블릿 컨텍스트를 가진다. 사용자는 톰캣에 배포되는 어플리케이션이라도 세션은 별도로 할당받는다.
- 서블릿 컨텍스트 : 서블릿 컨테이너와 통신하기 위해서 사용되는 메소드를 지원하는 인터페이스로 서블릿과 서블릿 컨테이너 간 연동을 위해 생성되는 Context이다. 톰캣을 구동하여 서블릿 컨테이너가 생성되면 웹어플리케이션 별 web.xml을 이용해 웹어플리케이션마다 서블릿 컨텍스트를 초기화하며 생성하고 서블릿 컨테이너가 종료되면 소멸된다.
- DispatcherServlet : 클라이언트의 요청을 받아 필요한 처리를 한 뒤, 개발자가 구현한 요청에 맞는 핸들러에게 요청을 Dispatch하고 해당 Handler의 실행결과를 Response형태로 만드는 역할을 한다. 서블릿 컨테이너가 컨텍스트를 초기화하는 시점에 생성된다. 
- ?서블릿 컨텍스트를 초기화하는 방법? : web.xml 배포기술자 설정, WebApplicationInitalizer 구현
- 필터 :<span style="color:gray">스프링에서 요청이 구현한 Contorller로 들어오기 전에 처리해야할 작업들이 있다. 인증 인가, XSS방어, 인코딩 등이 그것인데 이러한 작업은 컨트롤러메서드에서 수행하는 것 보다 공통적으로 처리하는 것이 효율적이다. 이 작업을 위한 기능이 필터와 인터셉터</span> JavaEE 표준 스펙 기능으로 디스패터 서블릿에 요청이 전달되기 전/후에 url패턴에 맞는 모든 요청에 대해 부가작업을 처리할 수 있는 기능을 제공한다. init메소드는 필터 객체를 초기화하고 서비스에 추가하기 위한 메소드이다. doFilter메소드는 url-pattern에 맞는 모든 HTTP요청이 디스패처 서블릿으로 전달되기 전에 웹컨테이너에 의해 실행되는 메소드이다. doFilter의 파라미터로는 FilterChain이 있는데, FilterChain의 doFilter를 통해 타음 대상으로 요청을 전달하게 된다.(chain.dofilter()) 전후에 필요한 처리과정을 넣어줌으로써 원하는 처리를 진행할 수 있다. destroy는 필터 객체를 서비스에서 제거하고 사용하는 자원을 반환하기 위한 메소드이다.
- Interceptor : Spring이 제공하는 기술로써 디스패처 서블릿이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공한다. 디스패처서블릿은 핸들러 매핑을 통해 적절한 컨트롤러를 찾도록 요청하는데, 그 결과로 HandlerExecutionChain(실행체인)을 돌려준다. 실행체인은 1개 이상의 인터셉터가 등록되어 있다면 순차적으로 인터셉터들을 거쳐 컨트롤러가 실행되도록 하고 인터셉터가 없다면 바로 컨트롤러를 실행한다. 
|차이|필터|인터셉터|
|----|----|-------|
|용도|공통된 보안, 인증, 인가작업/ 모든 요청에 대한 로깅,감사/ 이미지,데이터 압축 및 문자열인코딩|세부적인 보안 및 인증,인가 공통작업/ API호출에 대한 로깅,감사/ 컨트롤러로 넘겨주는 데이터의 가공|
|Request, Response객체조작 가능 여부|조작가능: 필터가 다음 필터를 호출하기위해서는 FilterChain을 해주어야하는데 이때 req,resp객체를 넘겨주므로 원하는 객체를 넣어줄수도있다.|불가능: 디스패처서블릿이 여러 인터셉터 목록을 가지고있고, for문으로 순차적으로 실행시키기 때문에 true를 반환하면 다음 인터셉서가 실행되거나 컨트롤러로 요청이 전달되며, false면 안됨.|
- Listener : 웹 컨테이너는 웹어플리케이션이 시작,종료되는 시점에 특정 클래스의 메서드를 실행할 수 있는 기능을 제공한다. 단일한 요청이 들어오면 처리가 쉽지만 여러개의 요청이 들어오는 경우에는 코드중복이 발생할 수 있고, DB가 다운되거나 제대로 구성되지 않은 경우 첫번째 클라이언트요청이 서버에 올때까지 존재를 알 수 없기때문에 이런 시나리오를 처리하기 위해서 리스너 인터페이스를 사용한다. web.xml 파일에 <listner> 태그와 <listener-class>태그를 사용하여 클래스 이름을 명시할 수 있다. <context-param>은 서블릿 컨텍스트 내 모든 서블릿이 공유하는 일종의 변수를 선언하는 역할을 한다. 
- 루트 컨테이너 : 

- HandlerMapping : 핸들러(컨트롤러)를 조회한다. 핸들러 매핑에서 컨트롤러를 찾을 수 있어야 한다. 스프링 빈의 이름으로 핸들러를 찾아야 한다.
- HandlerAdapter : 찾은 핸들러를 실행할 핸들러 어댑터가 필요하다. Controller 인터페이스를 실행할 핸들러 어댑터를 찾고 실행해야한다. >>스프링은 이미 구현되어있어서 개발자가 직접 만드는 일은 없다! 
- ViewResolver : 
- ModelAndView
- Contoller(Spring)
- SpringMVC 요청처리흐름
- Spring Contoller에서 요청처리방법(parameter, attribute, redirect, session, forward, 반환유형의 종류)